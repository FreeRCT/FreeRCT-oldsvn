#!/bin/bash

# $Id$
#
# This file is part of FreeRCT.
# FreeRCT is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
# FreeRCT is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with FreeRCT. If not, see <http://www.gnu.org/licenses/>.
#

# Files
CONFIG_LOG="config.log"
REPLACEFILES="Makefile.in src/Makefile.in src/rcdgen/Makefile.in graphics/rcd/Makefile.in src/rev.cpp.in"

# Commands/Programs
PKGCONFIG="pkg-config --modversion"
GREP="grep"

log() {
	if [ "$1" = "1" ]; then
		shift
		echo "$@"
	else
		shift
	fi
	echo "$@" >> $CONFIG_LOG
}

detect_os() {
	os=$host
	if [ -z "$os" ]; then
		os=$(LC_ALL=C uname)
	fi

	if [ -z "$os" ]; then
		log 1 "detecting OS... none detected"
		exit 1
	fi
	# Change to upper case, and strip non-alphanumeric characters
	os=$(echo "$os" | tr '[:lower:]' '[:upper:]' | tr -cd '[:alnum:]')

	log 1 "detecting OS... detected $os"
}

detect_lib() {
	# Generic function for detecting libraries
	# Params:
	# $1 - library name
	# $2 - command

	version=$($2)
	ret=$?
	log 2 "executing $2"
	log 2 "  returned $(echo "$version" | head -1)" # Truncate to reduce useless output
	log 2 "  exit code $ret"
	if [ -z "$version" ] || [ "$ret" != "0" ]; then
		log 1 "checking $1.. not found"
		exit 1
	fi
	log 1 "checking $1... found v$(echo "$version" | $GREP --only-matching '[0-9]\+\.[0-9]\+\(\.[0-9]\+\)\?')"
}

find_version() {
	# Stable releases: "x.x.x" (NYI)
	# Trunk  releases: "YYYYMMDD-HHmm.rev"
	COMMIT_DATE="norev"
	LAST_REV="000"
	VCS="none"
	SHORT_VCS="n"
	if [ -d "$ROOT_DIR/.svn" ] || [ -d "$ROOT_DIR/../.svn" ]; then
		COMMIT_DATE=$(date +"%Y%m%d-%H%M" -ud "$(LC_ALL=C svn info | grep 'Changed Date' | cut -c20-45)")
		LAST_REV=$(LC_ALL=C svn info | grep 'Changed Rev' | cut -d' ' -f4)
		VCS="svn"
		SHORT_VCS="r"
	elif [ -d "$ROOT_DIR/.git" ]; then
		if [ -d .git/svn  ] && [ x != x"$(ls -A .git/svn/)" ]; then
			COMMIT_DATE=$(date +"%Y%m%d-%H%M" -ud "$(LC_ALL=C git svn info | grep 'Changed Date' | cut -c20-45)")
			LAST_REV=$(LC_ALL=C git svn info | grep 'Changed Rev' | cut -d' ' -f4)
			VCS="gitsvn"
			SHORT_VCS="r"
		else
			COMMIT_DATE=$(date +"%Y%m%d-%H%M" -ud "$(LC_ALL=C git show -s --format="%ci" HEAD)")
			LAST_REV=$(LC_ALL=C git rev-list HEAD --count)
			VCS="git"
			SHORT_VCS="g"
		fi
	elif [ -d "$ROOT_DIR/.hg" ]; then
		COMMIT_DATE=$(date +"%Y%m%d-%H%M" -ud "$(LC_ALL=C hg parent --template="{date|isodate}")")
		LAST_REV=$(LC_ALL=C hg parent --template="{svnrev}")
		if [ -z "$LAST_REV" ]; then
			LAST_REV=$(LC_ALL=C hg parent --template="{rev}")
			VCS="hg"
			SHORT_VCS="h"
		else
			VCS="hgsvn"
			SHORT_VCS="r"
		fi
	fi
	log 1 "checking revision... $VCS detection"
	if [ "$VCS" = "none" ]; then
		log 1 "WARNING: there is no means to determine the version."
		log 1 "WARNING: please use a subversion, mercurial, or git checkout of FreeRCT."
		log 1 "WARNING: USE WITH CAUTION!"

		sleep 5
	fi

	log 2 "  commit date: $COMMIT_DATE"
	log 2 "  last revision: $LAST_REV"

	VERSION_STRING=$COMMIT_DATE"."$SHORT_VCS$LAST_REV
	log 1 "identifying version... $VERSION_STRING"
}

check_params() {
	detect_os
	detect_lib "sdl" "sdl-config --version"
	detect_lib "SDL_ttf" "$PKGCONFIG SDL_ttf"
	detect_lib "libpng" "libpng-config --version"
	detect_lib "flex" "flex --version"
	detect_lib "bison" "bison --version"
}

make_sed() {
	for i in $REPLACEFILES
	do
		log 1 "Generating ${i%.in}..."
		sed -e s@!!FREERCT!!@"$FREERCT"@g \
		    -e s@!!RCDGEN!!@"$RCDGEN"@g \
		    -e s@!!VERSION!!@"$VERSION_STRING"@g \
		< "$i" > "${i%.in}"
	done
}

# Start
echo "" > $CONFIG_LOG

# Find out where configure is (in what dir)
ROOT_DIR=${0%/*}
# For MSYS/MinGW we want to know the FULL path. This as that path is generated
# once you call an outside binary. Having the same path for the rest is needed
# for dependency checking.
# pwd -W returns said FULL path, but doesn't exist on others so fall back.
ROOT_DIR=$(cd "$ROOT_DIR" && (pwd -W 2>/dev/null || pwd 2>/dev/null))
if [ -n "$(echo "$ROOT_DIR" | grep '[^-_A-Za-z0-9\/\\\.:]')" ]; then
	echo "WARNING: The path contains a non-alphanumeric character that might cause"
	echo "         failures in subsequent build stages. Any failures with the build"
	echo "         will most likely be caused by this."
fi
log 1 "detecting root dir... $ROOT_DIR"

check_params
find_version

EXE=""
if [ "$os" = "MINGW" ] || [ "$os" = "CYGWIN" ] || [ "$os" = "OS2" ] || [ "$os" = "DOS" ] || [ "$os" = "WINCE" ]; then
	EXE=".exe"
fi

FREERCT="freerct$EXE"
RCDGEN="rcdgen$EXE"

make_sed
